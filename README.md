# greenlit-takehome

Your take home project is to make a simple CRUD api using fastapi, sqlalchemy, and postgres.

create a new repo named greenlit-takehome on github.com and add me as a collaborator (github.com/BTruer)
install python 3.10.x on your local machine
install poetry which is like a package manage and virtual env (this will ensure that both of us can run the application locally the same way) (https://python-poetry.org/)
in a terminal/cmd clone your repo (git clone git@github.com:yourAccount/greenlit-takehome.git)
cd into your repo (cd greenlit-takehome)
poetry init
for the name “simplecrud”
none of the other settings matter except:
for python version put "^3.10"
and install packages interactively you can say "no"
https://fastapi.tiangolo.com/#installation

poetry add fastapi

poetry add "uvicorn[standard]"

poetry add == pip install
create a main.py file with

from typing import Union

from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def read_root():
    return {"Hello": "World"}

@app.get("/items/{item_id}")
def read_item(item_id: int, q: Union[str, None] = None):
    return {"item_id": item_id, "q": q}
poetry run uvicorn main:app --reload

anytime you want to run anything in your virtualenv use poetry run before the command
so for example instead of running python you would run poetry run python to get the python shell
navigate to http://127.0.0.1:8000/items/5?q=somequery

you should get back {"item_id": 5, "q": "somequery"}
navigate to http://127.0.0.1:8000/docs to see the autogenerated api docs

Now you have a basic fastapi app!

Now setup a hosted postgres database. You basically want a db in cloud that you get the connection details for and connect the api to. Your options are: https://www.elephantsql.com/, supabase.com, or render.com which all have no credit card free options. You can use another one too if you want but I found these to be the easiest. Basically just create a free postgres database.

grab or create the connection string which should look like:
postgres://username:password@urlofserver.com/databasename ← you will use this string in your code
(optional) to help you debug / understand you can also just connect to the database directly with pgadmin (desktop application) OR psql (cli) or any database viewer application
poetry add pydantic SQLAlchemy
https://fastapi.tiangolo.com/tutorial/sql-databases/

Now following this^ as an example your actual tasks are:

to CRUD endpoints for the following tables:
users

first_name (str)
last_name (str)
email (str)
minimun_fee (int)
films

title (str)
description (str)
budget (int)
release_year (int)
genres (list[str])
companies

name (str)
contact_email_address (str)
phone_number (str)
implement the following relationships / join tables
users and films have a many to many relationship where the role of the user can be either “writer”, “producer”, or “director”
users and companies have a many to many relationship where the role is “owner” or “member”
companies and films have a one to may relationship
implement CRU (create, read, and update only) for the user’s role’s with films and user’s role’s companies
Some helpful things:

You do not need a migration tool (sqlachemy’s alembic) you can just setup the tables once in python like the tutorial gives or by creating them manually.

Read the fastapi documentation carefully there are alot of gotchas!

There are many many ways to write queries in python and sqlachemy outside of whats in the documentation in fastapi.

If you are new to fastapi and poetry you might get errors. Don’t worry 95% of errors have already happened to others so google and chatgpt gemini whatever are your friend here.

Sqlachemy documentation is messy so google is better alot of time. SQLachemy is the ORM / way to interact with the database.

Make sure you understand the difference between views, crud, models, and schemas.

views - where you write your endpoints

crud - where you actually do your crud/changes to the model objects

models - where you define your tables

schemas - where you define your input and outputs of your views (serialization); ensure the types of postgres db translate to their python types which is key for schemas to work.

These all need to be consistent for the app to work properly.